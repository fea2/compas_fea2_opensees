"""
This script reads results from .out files generated by a finite element analysis and converts them into an SQLite database.
It supports various types of field outputs such as displacements, reaction forces, reaction moments, stresses, and section forces.
The script creates tables in the SQLite database to store these results and their descriptions.
"""

import os
import numpy as np


def read_results_file(connection, field_output):
    """
    Read the .out results file and convert it to a dictionary.

    Parameters
    ----------
    database_path : path
        Path to the folder where the sqlite database will be created
    database_name : str
        Name of the database
    field_output : :class:`compas_fea2.problem.FieldOutput`
        FieldOutput object containing the nodes and/or element outputs to extract.
    """

    model = field_output.model
    step = field_output.step
    field_name = field_output.field_name
    problem_path = field_output.problem.path

    results = []
    with open(os.path.join(problem_path, f"{field_name}.out"), "r") as f:
        lines = f.readlines()
        for line in lines:
            columns = line.split()

            input_key = int(columns[0])  # Convert the first column to int
            member = getattr(model, field_output.results_func_output)(input_key)[0]

            values = list(map(lambda x: round(float(x), 6), columns[1:]))
            if not values:
                continue

            # NOTE: OpenSees outputs the stresses at the integration points, so we need to average them to get the element stresses
            if field_name == "s2d":
                num_integration_points = 4
                num_columns = len(values) // num_integration_points
                reshaped_data = np.array(values).reshape((num_integration_points, num_columns))
                averages = np.mean(reshaped_data, axis=0)
                values = averages.tolist()
                # NOTE: The OpenSees output is generalised stress, so we need to convert it to True stress
                t = member.section.t
                true_stresses = {
                    "sigma_11": values[0] / t,
                    "sigma_22": values[1] / t,
                    "tau_12": values[2] / t,
                    "sigma_b11": 6 * values[3] / t**2,
                    "sigma_b22": 6 * values[4] / t**2,
                    "sigma_b12": 6 * values[5] / t**2,
                    "tau_q1": values[6] / (t * 5 / 6),  # Assuming shear area = 5/6 * t
                    "tau_q2": values[7] / (t * 5 / 6),
                }
                values = list(true_stresses.values())

            if len(values) < len(field_output.components_names):
                values = values + [0.0] * (len(field_output.components_names) - len(values))
            elif len(values) > len(field_output.components_names):
                values = values[: len(field_output.components_names)]
            else:
                values = values

            results.append([member.key] + [step.name, member.part.name] + values)

    field_output.create_sql_table(connection, results)


def process_modal_shapes(connection, step):
    problem_path = step.problem.path
    model = step.model

    eigenvalues = []
    with open(os.path.join(problem_path, "eigenvalues.out"), "r") as f:
        lines = f.readlines()
        for line in lines:
            eigenvalues.append(line.split())

    eigenvectors = []
    with open(os.path.join(problem_path, "eigenvectors.out"), "r") as f:
        lines = f.readlines()
        for line in lines:
            eigenvectors.append(line.split())

    cursor = connection.cursor()

    # Create table for eigenvalues
    cursor.execute(
        """
    CREATE TABLE IF NOT EXISTS eigenvalues (
        id INTEGER PRIMARY KEY,
        step TEXT,
        mode INTEGER,
        lambda REAL,
        omega REAL,
        freq REAL,
        period REAL
        )
    """
    )

    # Insert eigenvalues into the database
    for eigenvalue in eigenvalues:
        cursor.execute(
            """
        INSERT INTO eigenvalues (step, mode, lambda, omega, freq, period)
        VALUES (?, ?, ?, ?, ?, ?)
        """,
            [step.name] + eigenvalue,
        )
    connection.commit()

    for i, eigenvector in enumerate(eigenvectors):
        if len(eigenvector) < 8:
            eigenvector = eigenvector + [0.0] * (8 - len(eigenvector))
        node = model.find_node_by_inputkey(int(eigenvector[1]))[0]
        eigenvectors[i] = [eigenvector[0], step.name, node.part.name, node.input_key] + eigenvector[2:]

    # Create table for modal shapes
    cursor.execute(
        f"""
    CREATE TABLE IF NOT EXISTS eigenvectors (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        mode INTEGER,
        step TEXT,
        part TEXT,
        key INTEGER,
        {",\n".join([f"{c} REAL" for c in ['x', 'y', 'z', 'xx', 'yy', 'zz']])}
        )
    """
    )
    # Insert modal shape data into the database
    for eigenvector in eigenvectors:
        cursor.execute(
            f"""
        INSERT INTO eigenvectors (mode, step, part, key, {", ".join([c for c in ['x', 'y', 'z', 'xx', 'yy', 'zz']])})
        VALUES (?, ?, ?, ?, ?, ? ,?, ?, ?, ?)
        """,
            eigenvector,
        )

    connection.commit()

    print(f"Modal shapes and eigenvalues successfully saved to {problem_path}")
